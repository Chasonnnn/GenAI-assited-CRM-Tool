#!/usr/bin/env python3
from __future__ import annotations

import json
import os
import re
import sys
from pathlib import Path
from typing import Any


ROOT = Path(__file__).resolve().parents[1]
API_ROOT = ROOT / "apps" / "api"
WEB_OUT = ROOT / "apps" / "web" / "lib" / "types" / "surrogate.generated.ts"

TARGET_SCHEMAS = [
    "SurrogateSource",
    "SurrogateListItem",
    "SurrogateRead",
    "SurrogateListResponse",
    "SurrogateStatusChange",
    "SurrogateStatusHistoryRead",
    "SurrogateStatusChangeResponse",
]

os.environ.setdefault("ENV", "test")
os.environ.setdefault(
    "DATABASE_URL",
    "postgresql+psycopg://user:pass@localhost:5432/crm_dev",
)
sys.path.insert(0, str(API_ROOT))

from app.main import app  # noqa: E402


def _ref_name(ref: str) -> str:
    return ref.rsplit("/", maxsplit=1)[-1]


def _dedupe(items: list[str]) -> list[str]:
    seen: set[str] = set()
    out: list[str] = []
    for item in items:
        if item in seen:
            continue
        seen.add(item)
        out.append(item)
    return out


def _maybe_parenthesize_for_array(type_expr: str) -> str:
    return f"({type_expr})" if " | " in type_expr else type_expr


def _is_identifier(name: str) -> bool:
    return bool(re.match(r"^[A-Za-z_$][A-Za-z0-9_$]*$", name))


def _format_property_name(name: str) -> str:
    return name if _is_identifier(name) else json.dumps(name)


def _ts_from_schema(schema: dict[str, Any], components: dict[str, Any]) -> str:
    if "$ref" in schema:
        return _ref_name(schema["$ref"])

    if "anyOf" in schema:
        variants = [_ts_from_schema(part, components) for part in schema["anyOf"]]
        return " | ".join(_dedupe(variants))

    if "enum" in schema:
        return " | ".join(json.dumps(value) for value in schema["enum"])

    schema_type = schema.get("type")
    if schema_type == "array":
        inner = _ts_from_schema(schema.get("items", {}), components)
        return f"{_maybe_parenthesize_for_array(inner)}[]"

    if schema_type == "object":
        additional = schema.get("additionalProperties")
        if additional:
            value_type = _ts_from_schema(additional, components)
            return f"Record<string, {value_type}>"
        return "Record<string, unknown>"

    primitive_map = {
        "string": "string",
        "integer": "number",
        "number": "number",
        "boolean": "boolean",
        "null": "null",
    }
    return primitive_map.get(schema_type, "unknown")


def _render_named_schema(name: str, schema: dict[str, Any], components: dict[str, Any]) -> list[str]:
    if schema.get("type") == "object" and schema.get("properties"):
        required = set(schema.get("required", []))
        lines = [f"export interface {name} {{"]  # keep JSON schema order for stable diffs
        for prop_name, prop_schema in schema["properties"].items():
            ts_type = _ts_from_schema(prop_schema, components)
            optional = "?" if prop_name not in required else ""
            lines.append(f"    {_format_property_name(prop_name)}{optional}: {ts_type};")
        lines.append("}")
        return lines

    ts_type = _ts_from_schema(schema, components)
    return [f"export type {name} = {ts_type};"]


def render_typescript() -> str:
    openapi = app.openapi()
    components = openapi.get("components", {}).get("schemas", {})

    lines: list[str] = [
        "// Generated by scripts/gen_surrogate_contracts.py. Do not edit.",
        "",
    ]

    for schema_name in TARGET_SCHEMAS:
        if schema_name not in components:
            raise KeyError(f"Schema not found in OpenAPI components: {schema_name}")
        lines.extend(_render_named_schema(schema_name, components[schema_name], components))
        lines.append("")

    lines.extend(
        [
            "export type SurrogateStatusHistory = SurrogateStatusHistoryRead;",
            "export type SurrogateStatusChangePayload = SurrogateStatusChange;",
            "",
        ]
    )
    return "\n".join(lines)


def main() -> None:
    rendered = render_typescript()
    WEB_OUT.parent.mkdir(parents=True, exist_ok=True)
    WEB_OUT.write_text(rendered, encoding="utf-8")


if __name__ == "__main__":
    main()
